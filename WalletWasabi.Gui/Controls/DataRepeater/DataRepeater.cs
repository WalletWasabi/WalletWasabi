using System.Reactive.Linq;
using Avalonia;
using Avalonia.Controls.Primitives;
using System;
using System.Linq;
using System.ComponentModel;
using System.Collections;
using Avalonia.Styling;
using System.Reflection;
using System.Linq.Expressions;
using System.Collections.Generic;
using ReactiveUI;

namespace WalletWasabi.Gui.Controls.DataRepeater
{
	public class DataRepeater : TemplatedControl
	{
		public DataRepeater()
		{
			this.WhenAnyValue(x => x.Items)
				.Subscribe(x => DoAutoGeneratedHeaders(x));
		}

		internal static readonly DirectProperty<DataRepeater, DataRepeaterHeaderDescriptors> HeaderDescriptorsProperty =
			AvaloniaProperty.RegisterDirect<DataRepeater, DataRepeaterHeaderDescriptors>(
				nameof(HeaderDescriptors),
				o => o.HeaderDescriptors,
				(o, v) => o.HeaderDescriptors = v);

		private DataRepeaterHeaderDescriptors _headerDescriptors;

		internal DataRepeaterHeaderDescriptors HeaderDescriptors
		{
			get => _headerDescriptors;
			set => SetAndRaise(HeaderDescriptorsProperty, ref _headerDescriptors, value);
		}

		public static readonly DirectProperty<DataRepeater, IEnumerable> ItemsProperty =
			AvaloniaProperty.RegisterDirect<DataRepeater, IEnumerable>(
				nameof(Items),
				o => o.Items,
				(o, v) => o.Items = v);

		private IEnumerable _items;

		public IEnumerable Items
		{
			get => _items;
			set => SetAndRaise(ItemsProperty, ref _items, value);
		}

		private void DoAutoGeneratedHeaders(IEnumerable source)
		{
			if (source is null)
			{
				return;
			}

			int i = 0;
			var xdghList = new DataRepeaterHeaderDescriptors();
			var dataType = GetItemType(source);
			foreach (var property in dataType.GetProperties())
			{
				string dName;
				
				var dispNameAttrib = (DisplayNameAttribute)property
										.GetCustomAttributes(typeof(DisplayNameAttribute), false)
										.SingleOrDefault();

				if (dispNameAttrib is null)
				{
					continue;
				}
				else
				{
					dName = dispNameAttrib.DisplayName;
				}

				var xdgh = new DataRepeaterHeaderDescriptor()
				{
					HeaderText = dName,
					PropertyName = property.Name,
				};

				if (typeof(IComparable).IsAssignableFrom(property.PropertyType) && property.CanWrite)
				{
					xdgh.IsSortable = true;
					xdgh.GetterDelegate = GeneratePropertyGetter(property, dataType);
				}

				i++;

				xdghList.Add(xdgh);
			}

			HeaderDescriptors = xdghList;

			HeaderDescriptors.SortHeader += OnSortHeader;

			DataType = dataType;
		}

		private void OnSortHeader(DataRepeaterHeaderDescriptor target)
		{
			if (!target.IsSortable)
			{
				return;
			}

			IEnumerable<object> nItem = null;

			switch (target.InternalSortState)
			{
				case DataRepeaterHeaderDescriptor.SortState.Ascending:
					nItem = ((IEnumerable<object>)Items).OrderBy(target.GetterDelegate);
					break;
				case DataRepeaterHeaderDescriptor.SortState.Descending:
					nItem = ((IEnumerable<object>)Items).OrderByDescending(target.GetterDelegate);
					break;
			}

			if (nItem is null)
			{
				return;
			}

			SetAndRaise(ItemsProperty, ref _items, nItem);
		}

		public Func<object, object> GeneratePropertyGetter(PropertyInfo propertyInfo, Type source)
		{
			var sourceObjectParam = Expression.Parameter(typeof(object));

			Expression returnExpression = Expression.Call(Expression.Convert(sourceObjectParam, source), propertyInfo.GetMethod);

			if (!propertyInfo.PropertyType.IsClass)
			{
				returnExpression = Expression.Convert(returnExpression, typeof(object));
			}

			return (Func<object, object>)Expression.Lambda(returnExpression, sourceObjectParam)
												   .Compile();
		}

		public static readonly DirectProperty<DataRepeater, Type> DataTypeProperty =
			AvaloniaProperty.RegisterDirect<DataRepeater, Type>(
				nameof(DataType),
				o => o.DataType,
				(o, v) => o.DataType = v);

		private Type _dataType;

		public Type DataType
		{
			get => _dataType;
			set
			{
				if (value is null)
				{
					return;
				}

				SetAndRaise(DataTypeProperty, ref _dataType, value);
			}
		}

		internal Type GetItemType(IEnumerable list)
		{
			Type listType = list.GetType();
			Type itemType = null;

			if (FindGenericType(typeof(IEnumerable<>), listType) != null)
			{
				itemType = GetEnumerableItemType(listType);
			}

			// Bare IEnumerables mean that result type will be object.  In that case, we try to get something more interesting
			if (itemType == null || itemType == typeof(object))
			{
				// We haven't located a type yet.. try a different approach.
				// Does the list have anything in it?

				IEnumerator en = list.GetEnumerator();
				if (en.MoveNext() && en.Current != null)
				{
					return en.Current.GetType();
				}
			}

			// if we're null at this point, give up
			return itemType;
		}

		internal Type GetEnumerableItemType(Type enumerableType)
		{
			Type type = FindGenericType(typeof(IEnumerable<>), enumerableType);
			if (type != null)
			{
				return type.GetGenericArguments()[0];
			}
			return enumerableType;
		}

		internal Type FindGenericType(Type definition, Type type)
		{
			while ((type != null) && (type != typeof(object)))
			{
				if (type.IsGenericType && (type.GetGenericTypeDefinition() == definition))
				{
					return type;
				}
				if (definition.IsInterface)
				{
					foreach (var type2 in type.GetInterfaces())
					{
						var type3 = FindGenericType(definition, type2);
						if (type3 != null)
						{
							return type3;
						}
					}
				}
				type = type.BaseType;
			}
			return null;
		}
	}
}
