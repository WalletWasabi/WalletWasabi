using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace WalletWasabi.Fluent.Generators;

[Generator]
public class OapthGenerator : ISourceGenerator
{
	internal const string OaphAttributeDisplayString = "WalletWasabi.Fluent.OaphAttribute";

	private const string ReactiveObjectDisplayString = "ReactiveUI.ReactiveObject";

	private const string ObservableAsPropertyHelperMetadataName = "ObservableAsPropertyHelper`1";

	private const string AttributeText = @"// <auto-generated />
#nullable enable
using System;

namespace WalletWasabi.Fluent
{
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    sealed class OaphAttribute : Attribute
    {
        public OaphAttribute()
        {
        }

        public string? PropertyName { get; set; }
    }
}";

	public void Initialize(GeneratorInitializationContext context)
	{
		// System.Diagnostics.Debugger.Launch();
		context.RegisterForPostInitialization((i) =>
		{
			i.AddSource("OaphAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8));
		});

		context.RegisterForSyntaxNotifications(() => new OaphSyntaxReceiver());
	}

	public void Execute(GeneratorExecutionContext context)
	{
		if (context.SyntaxContextReceiver is not OaphSyntaxReceiver receiver)
		{
			return;
		}

		var attributeSymbol = context.Compilation.GetTypeByMetadataName(OaphAttributeDisplayString);
		if (attributeSymbol is null)
		{
			return;
		}

		var notifySymbol = context.Compilation.GetTypeByMetadataName(ReactiveObjectDisplayString);
		if (notifySymbol is null)
		{
			return;
		}

		// TODO: https://github.com/dotnet/roslyn/issues/49385
#pragma warning disable RS1024
		var groupedFields = receiver.FieldSymbols.GroupBy(f => f.ContainingType);
#pragma warning restore RS1024

		foreach (var group in groupedFields)
		{
			var classSource = ProcessClass(group.Key, group.ToList(), attributeSymbol, notifySymbol);
			if (classSource is null)
			{
				continue;
			}
			context.AddSource($"{group.Key.Name}_Oaph.cs", SourceText.From(classSource, Encoding.UTF8));
		}
	}

	private static string? ProcessClass(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields, ISymbol attributeSymbol, INamedTypeSymbol notifySymbol)
	{
		if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
		{
			return null;
		}

		string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

		var addNotifyInterface = !classSymbol.Interfaces.Contains(notifySymbol);
		var baseType = classSymbol.BaseType;
		while (true)
		{
			if (baseType is null)
			{
				break;
			}

			if (SymbolEqualityComparer.Default.Equals(baseType, notifySymbol))
			{
				addNotifyInterface = false;
				break;
			}

			baseType = baseType.BaseType;
		}

		var source = new StringBuilder();

		var format = new SymbolDisplayFormat(
			typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
			genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

		if (addNotifyInterface)
		{
			source.Append($@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format)} : {notifySymbol.ToDisplayString()}
    {{");
		}
		else
		{
			source.Append($@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format)}
    {{");
		}

		foreach (IFieldSymbol fieldSymbol in fields)
		{
			ProcessField(source, fieldSymbol, attributeSymbol);
		}

		source.Append($@"
    }}
}}");

		return source.ToString();
	}

	private static void ProcessField(StringBuilder source, IFieldSymbol fieldSymbol, ISymbol attributeSymbol)
	{
		var fieldName = fieldSymbol.Name;
		var fieldType = fieldSymbol.Type;
		var attributeData = fieldSymbol.GetAttributes().Single(ad => ad?.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) ?? false);
		var overridenNameOpt = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "PropertyName").Value;
		var propertyName = TypedStringHelpers.ChoosePropertyName(fieldName, overridenNameOpt);

		if (propertyName is null || propertyName.Length == 0 || propertyName == fieldName)
		{
			// Issue a diagnostic that we can't process this field.
			return;
		}

		if (fieldType.MetadataName != ObservableAsPropertyHelperMetadataName)
		{
			// Issue a diagnostic that field must be oaph type.
			return;
		}

		if (fieldType is not INamedTypeSymbol fieldNamedType || fieldNamedType.TypeArguments.Length != 1)
		{
			// Issue a diagnostic that field must have one type argument.
			return;
		}

		source.Append($@"
        public {fieldNamedType.TypeArguments[0]} {propertyName} => {fieldName}.Value;");
	}
}
