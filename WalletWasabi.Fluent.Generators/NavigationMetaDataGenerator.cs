using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WalletWasabi.Fluent.Generators;

[Generator(LanguageNames.CSharp)]
public class NavigationMetaDataGenerator : IIncrementalGenerator
{
	public const string NavigationMetaDataAttributeDisplayString = "WalletWasabi.Fluent.NavigationMetaDataAttribute";
	private const string NavigationMetaDataDisplayString = "WalletWasabi.Fluent.NavigationMetaData";
	private const string RoutableViewModelDisplayString = "WalletWasabi.Fluent.ViewModels.Navigation.RoutableViewModel";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all classes that have the [NavigationMetaData(...)] attribute
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) =>
					node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
				transform: static (ctx, cancellationToken) =>
				{
					var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken);
					if (symbol is not INamedTypeSymbol namedTypeSymbol)
					{
						return null;
					}

					var attributes = namedTypeSymbol.GetAttributes();
					var hasAttribute = attributes.Any(attr => attr.AttributeClass?.ToDisplayString() == NavigationMetaDataAttributeDisplayString);

					return hasAttribute ? namedTypeSymbol : null;
				})
			.Where(static m => m is not null)
			.Select(static (symbol, _) => symbol!);

		var compilationAndSymbols = context.CompilationProvider
			.Combine(provider.Collect());

		context.RegisterSourceOutput(
			compilationAndSymbols,
			static (spc, source) =>
			{
				var (compilation, classSymbols) = source;

				var attributeSymbol = compilation.GetTypeByMetadataName(NavigationMetaDataAttributeDisplayString);
				var metadataSymbol = compilation.GetTypeByMetadataName(NavigationMetaDataDisplayString);

				if (attributeSymbol is null || metadataSymbol is null)
				{
					return;
				}

				foreach (var namedTypeSymbol in classSymbols)
				{
					var classSource = ProcessClass(compilation, namedTypeSymbol, attributeSymbol, metadataSymbol);

					if (classSource is not null)
					{
						spc.AddSource($"{namedTypeSymbol.Name}_NavigationMetaData.g.cs", SourceText.From(classSource, Encoding.UTF8));
					}
				}
			});
	}

	private static string? ProcessClass(Compilation compilation, INamedTypeSymbol classSymbol, INamedTypeSymbol attributeSymbol, INamedTypeSymbol metadataSymbol)
	{
		if (!SymbolEqualityComparer.Default.Equals(classSymbol.ContainingSymbol, classSymbol.ContainingNamespace))
		{
			return null;
		}

		string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

		var format = new SymbolDisplayFormat(
			typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
			genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

		var attributeData = classSymbol
			.GetAttributes()
			.Single(ad => ad?.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) ?? false);

		var isNavBarItem =
			attributeData.NamedArguments.Any(x => x.Key == "NavBarPosition") &&
			attributeData.NamedArguments.Any(x => x.Key == "NavBarSelectionMode");

		var implementedInterfaces = new List<string>();

		if (isNavBarItem)
		{
			var navBarSelectionMode = attributeData.NamedArguments.First(x => x.Key == "NavBarSelectionMode").Value.Value;
			if (navBarSelectionMode is int s)
			{
				if (s == 1)
				{
					implementedInterfaces.Add("INavBarButton");
				}
				else if (s == 2)
				{
					implementedInterfaces.Add("INavBarToggle");
				}
			}
		}

		var className = classSymbol.ToDisplayString(format);

		var implementedInterfacesString = implementedInterfaces.Count != 0
			? ": " + string.Join(", ", implementedInterfaces)
			: "";

		var source = new StringBuilder($$"""
			// <auto-generated />
			#nullable enable
			using System;
			using System.Threading.Tasks;
			using WalletWasabi.Fluent.ViewModels.Navigation;

			namespace {{namespaceName}};

			public partial class {{className}}{{implementedInterfacesString}}
			{

			""");

		source.Append(
			$$"""
				public static {{metadataSymbol.ToDisplayString()}} MetaData { get; } = new()
				{

			""");
		var length = attributeData.NamedArguments.Length;
		for (int i = 0; i < length; i++)
		{
			var namedArgument = attributeData.NamedArguments[i];

			source.AppendLine($"\t\t{namedArgument.Key} = " +
							  $"{(namedArgument.Value.Kind == TypedConstantKind.Array ? "new[] " : "")}" +
							  $"{namedArgument.Value.ToCSharpString()}{(i < length - 1 ? "," : "")}");
		}

		source.Append(
			"""
				};

			""");

		source.AppendLine(
			"""
				public static void RegisterAsyncLazy(Func<Task<RoutableViewModel?>> createInstance) => NavigationManager.RegisterAsyncLazy(MetaData, createInstance);
			""");
		source.AppendLine(
			"""
				public static void RegisterLazy(Func<RoutableViewModel?> createInstance) => NavigationManager.RegisterLazy(MetaData, createInstance);
			""");
		source.AppendLine(
			"""
				public static void Register(RoutableViewModel createInstance) => NavigationManager.Register(MetaData, createInstance);
			""");

		var routableClass = compilation.GetTypeByMetadataName(RoutableViewModelDisplayString);

		if (routableClass is { })
		{
			bool addRoutableMetaData = false;
			var baseType = classSymbol.BaseType;
			while (true)
			{
				if (baseType is null)
				{
					break;
				}

				if (SymbolEqualityComparer.Default.Equals(baseType, routableClass))
				{
					addRoutableMetaData = true;
					break;
				}

				baseType = baseType.BaseType;
			}

			if (addRoutableMetaData)
			{
				if (attributeData.NamedArguments.Any(x => x.Key == "NavigationTarget"))
				{
					source.AppendLine(
						"""
							public override NavigationTarget DefaultTarget => MetaData.NavigationTarget;
						""");
				}

				if (attributeData.NamedArguments.Any(x => x.Key == "Title"))
				{
					source.AppendLine(
						"""
							public override string Title { get => MetaData.Title!; protected set {} }
						""");
				}
			}

			if (attributeData.NamedArguments.Any(x => x.Key == "IconName"))
			{
				source.AppendLine(
					"""
						public string IconName => MetaData.IconName!;
					""");
			}

			if (attributeData.NamedArguments.Any(x => x.Key == "IconNameFocused"))
			{
				source.AppendLine(
					"""
						public string IconNameFocused => MetaData.IconNameFocused!;
					""");
			}
		}

		source.Append(
			"""
			}
			""");

		return source.ToString();
	}
}
