using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace WalletWasabi.Fluent.Generators.Generators;

[Generator(LanguageNames.CSharp)]
internal class AutoNotifyGenerator : IIncrementalGenerator
{
	private static SymbolDisplayFormat GeneratorSymbolDisplayFormat = new(
		typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
		genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

	public const string AutoNotifyAttributeDisplayString = "WalletWasabi.Fluent.AutoNotifyAttribute";
	private const string ReactiveObjectDisplayString = "ReactiveUI.ReactiveObject";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all fields decorated with [AutoNotify].
		var fieldProvider = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				fullyQualifiedMetadataName: AutoNotifyAttributeDisplayString,
				predicate: static (node, _) => node is VariableDeclaratorSyntax variableDeclarator,
				transform: static (ctx, ct) =>
				{
					var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, ct);
					return symbol as IFieldSymbol;
				})
			.Where(static symbol => symbol is not null)!
			.Select(static (x, _) => x!)
			.Collect();

		// Group fields by containing type + collect compilation
		var groupedProvider = fieldProvider
			.Combine(context.CompilationProvider)
			.Select(static (pair, cancellationToken) =>
			{
				var (fields, compilation) = pair;

				if (fields.IsDefaultOrEmpty)
				{
					return ImmutableArray<(INamedTypeSymbol, ImmutableArray<IFieldSymbol>)>.Empty;
				}

				var attributeSymbol = compilation.GetTypeByMetadataName(AutoNotifyAttributeDisplayString);
				if (attributeSymbol is null)
				{
					return ImmutableArray<(INamedTypeSymbol, ImmutableArray<IFieldSymbol>)>.Empty;
				}

				var notifySymbol = compilation.GetTypeByMetadataName(ReactiveObjectDisplayString);
				if (notifySymbol is null)
				{
					return ImmutableArray<(INamedTypeSymbol, ImmutableArray<IFieldSymbol>)>.Empty;
				}

				// Group by containing type (same as original)
#pragma warning disable RS1024 // Enable 'types' or 'symbols' comparer
				var grouped = fields
					.GroupBy(f => f.ContainingType)
					.Select(g => (g.Key, g.ToImmutableArray()))
					.ToImmutableArray();
#pragma warning restore RS1024

				return grouped;
			});

		context.RegisterSourceOutput(groupedProvider.Combine(context.CompilationProvider),
			static (spc, tuple) =>
			{
				var (groups, compilation) = tuple;

				if (groups.IsDefaultOrEmpty)
				{
					return;
				}

				var notifySymbol = compilation.GetTypeByMetadataName(ReactiveObjectDisplayString);
				if (notifySymbol is null)
				{
					return;
				}

				var attributeSymbol = compilation.GetTypeByMetadataName(AutoNotifyAttributeDisplayString);
				if (attributeSymbol is null)
				{
					return;
				}

				foreach (var (classSymbol, fields) in groups)
				{
					var source = ProcessClass(classSymbol, fields, notifySymbol, attributeSymbol);
					if (source is null)
					{
						continue;
					}

					var fileName = $"{classSymbol.Name}_AutoNotify.g.cs";
					spc.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
				}
			});
	}

	private static string? ProcessClass(INamedTypeSymbol classSymbol, ImmutableArray<IFieldSymbol> fields, INamedTypeSymbol notifySymbol, INamedTypeSymbol attributeSymbol)
	{
		if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
		{
			return null;
		}

		string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

		var addNotifyInterface = !classSymbol.Interfaces.Contains(notifySymbol);
		var baseType = classSymbol.BaseType;
		while (baseType is not null)
		{
			if (SymbolEqualityComparer.Default.Equals(baseType, notifySymbol))
			{
				addNotifyInterface = false;
				break;
			}

			baseType = baseType.BaseType;
		}

		var source = new StringBuilder();

		var classDisplay = classSymbol.ToDisplayString(GeneratorSymbolDisplayFormat);

		if (addNotifyInterface)
		{
			source.Append(
				$$"""
				// <auto-generated />

				#nullable enable
				using ReactiveUI;

				namespace {{namespaceName}};

				public partial class {{classDisplay}} : {{notifySymbol.ToDisplayString()}}
				{
				""");
		}
		else
		{
			source.Append(
				$$"""
				// <auto-generated />
				#nullable enable
				using ReactiveUI;

				namespace {{namespaceName}};

				public partial class {{classDisplay}}
				{
				""");
		}

		foreach (IFieldSymbol fieldSymbol in fields)
		{
			ProcessField(source, fieldSymbol, attributeSymbol);
		}

		source.Append(
			"""

			}
			""");

		return source.ToString();
	}

	private static void ProcessField(StringBuilder source, IFieldSymbol fieldSymbol, ISymbol attributeSymbol)
	{
		var fieldName = fieldSymbol.Name;
		var fieldType = fieldSymbol.Type;
		var attributeData = fieldSymbol.GetAttributes().Single(ad => ad?.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) ?? false);
		var propertyName = GetPropertyName(fieldName, attributeData);

		if (propertyName is null || propertyName.Length == 0 || propertyName == fieldName)
		{
			// Issue a diagnostic that we can't process this field.
			return;
		}

		var setterModifier = GetSetterModifier(attributeData);

		if (setterModifier is null)
		{
			source.Append(
				$$"""

					public {{fieldType}} {{propertyName}}
					{
						get => {{fieldName}};
					}
				""");
		}
		else
		{
			source.Append(
				$$"""

					public {{fieldType}} {{propertyName}}
					{
						get => {{fieldName}};
						{{setterModifier}}set => this.RaiseAndSetIfChanged(ref {{fieldName}}, value);
					}
				""");
		}
	}

	private static string? ChooseSetterModifier(TypedConstant overriddenSetterModifierOpt)
	{
		if (!overriddenSetterModifierOpt.IsNull && overriddenSetterModifierOpt.Value is not null)
		{
			var value = (int)overriddenSetterModifierOpt.Value;
			return value switch
			{
				0 => null,// None
				1 => "",// Public
				2 => "protected ",// Protected
				3 => "private ",// Private
				4 => "internal ",// Internal
				_ => ""// Default
			};
		}
		else
		{
			return "";
		}
	}

	private static string? ChooseName(string fieldName, TypedConstant overriddenNameOpt)
	{
		if (!overriddenNameOpt.IsNull)
		{
			return overriddenNameOpt.Value?.ToString();
		}

		fieldName = fieldName.TrimStart('_');
		if (fieldName.Length == 0)
		{
			return string.Empty;
		}

		if (fieldName.Length == 1)
		{
			return fieldName.ToUpper();
		}

		return fieldName.Substring(0, 1).ToUpper() + fieldName.Substring(1);
	}

	public static string? GetPropertyName(string fieldName, AttributeData attributeData)
	{
		var overriddenNameOpt = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "PropertyName").Value;
		return ChooseName(fieldName, overriddenNameOpt);
	}

	public static string? GetSetterModifier(AttributeData attributeData)
	{
		var overriddenSetterModifierOpt = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "SetterModifier").Value;
		return ChooseSetterModifier(overriddenSetterModifierOpt);
	}
}
