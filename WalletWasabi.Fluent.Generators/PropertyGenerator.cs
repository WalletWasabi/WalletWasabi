using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace WalletWasabi.Fluent.Generators
{
	[Generator]
	public class PropertyGenerator : ISourceGenerator
	{
		private const string AttributeText = @"// <auto-generated />
#nullable enable
using System;

namespace WalletWasabi.Fluent
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public sealed class PropertyAttribute : Attribute
    {
        public PropertyAttribute(
            string propertyName,
            Type propertyType,
            bool isReadOnly = false,
            PropertyModifier getterModifier = PropertyModifier.None,
            PropertyModifier setterModifier = PropertyModifier.None)
        {
            PropertyName = propertyName;
            PropertyType = propertyType;
            IsReadOnly = isReadOnly;
            GetterModifier = getterModifier;
            SetterModifier = setterModifier;
        }
        public string PropertyName { get; set; }
        public Type PropertyType { get; set; }
        public bool IsReadOnly { get; set; }
        public PropertyModifier GetterModifier { get; set; }
        public PropertyModifier SetterModifier { get; set; }
    }
}";

		private const string ModifierText = @"// <auto-generated />

namespace WalletWasabi.Fluent
{
    public enum PropertyModifier
    {
        None = 0,
        Public = 1,
        Protected = 2,
        Private = 3,
        Internal = 4
    }
}";

		public void Initialize(GeneratorInitializationContext context)
		{
			// System.Diagnostics.Debugger.Launch();
			context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
		}

		public void Execute(GeneratorExecutionContext context)
		{
			if (context.Compilation.GetTypeByMetadataName("WalletWasabi.Fluent.PropertyModifier") == null)
			{
				context.AddSource("PropertyModifier", SourceText.From(ModifierText, Encoding.UTF8));
			}
			context.AddSource("PropertyAttribute", SourceText.From(AttributeText, Encoding.UTF8));

			if (context.SyntaxReceiver is not SyntaxReceiver receiver)
			{
				return;
			}

			var options = (context.Compilation as CSharpCompilation)?.SyntaxTrees[0].Options as CSharpParseOptions;
			var compilation = context.Compilation.AddSyntaxTrees(
				CSharpSyntaxTree.ParseText(SourceText.From(ModifierText, Encoding.UTF8), options),
				CSharpSyntaxTree.ParseText(SourceText.From(AttributeText, Encoding.UTF8), options));

			var attributeSymbol = compilation.GetTypeByMetadataName("WalletWasabi.Fluent.PropertyAttribute");
			if (attributeSymbol is null)
			{
				return;
			}

			var notifySymbol = compilation.GetTypeByMetadataName("ReactiveUI.ReactiveObject");
			if (notifySymbol is null)
			{
				return;
			}

			List<INamedTypeSymbol> namedTypeSymbols = new();

			foreach (var candidateClass in receiver.CandidateClasses)
			{
				var semanticModel = compilation.GetSemanticModel(candidateClass.SyntaxTree);
				var namedTypeSymbol = semanticModel.GetDeclaredSymbol(candidateClass);
				if (namedTypeSymbol is null)
				{
					continue;
				}

				var attributes = namedTypeSymbol.GetAttributes();
				if (attributes.Any(ad => ad?.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) ?? false))
				{
					namedTypeSymbols.Add(namedTypeSymbol);
				}
			}

			foreach (var namedTypeSymbol in namedTypeSymbols)
			{
				var classSource = ProcessClass(namedTypeSymbol, attributeSymbol, notifySymbol);
				if (classSource is not null)
				{
					context.AddSource($"{namedTypeSymbol.Name}_Properties.cs", SourceText.From(classSource, Encoding.UTF8));
				}
			}
		}

		private static string? ProcessClass(INamedTypeSymbol classSymbol, ISymbol attributeSymbol, INamedTypeSymbol notifySymbol)
		{
			if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
			{
				return null;
			}

			string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

			var addNotifyInterface = !classSymbol.Interfaces.Contains(notifySymbol);
			var baseType = classSymbol.BaseType;
			while (true)
			{
				if (baseType is null)
				{
					break;
				}

				if (SymbolEqualityComparer.Default.Equals(baseType, notifySymbol))
				{
					addNotifyInterface = false;
					break;
				}

				baseType = baseType.BaseType;
			}

			var source = new StringBuilder();

            var format = new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance
            );

			if (addNotifyInterface)
			{
				source.Append($@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format)} : {notifySymbol.ToDisplayString()}
    {{");

			}
			else
			{
				source.Append($@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format)}
    {{");
			}

			var attributes = classSymbol
				.GetAttributes()
				.Where(ad => ad?.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) ?? false);

			static string ChooseModifier(int value)
			{
				return value switch
				{
					// None
					0 => "",
					// Public
					1 => "public ",
					// Protected
					2 => "protected ",
					// Private
					3 => "private ",
					// Internal
					4 => "internal ",
					// Default
					_ => ""
				};
			}

			foreach (var attributeData in attributes)
			{
				if (attributeData is null || attributeData.ConstructorArguments.Length != 5)
				{
					continue;
				}

				var propertyName = (string?) attributeData.ConstructorArguments[0].Value;
				var propertyType = attributeData.ConstructorArguments[1].Value;
				var isReadOnly = (bool?) attributeData.ConstructorArguments[2].Value;
				var getterModifier = (int?) attributeData.ConstructorArguments[3].Value;
				var setterModifier = (int?) attributeData.ConstructorArguments[4].Value;

				if (propertyName is null || propertyType is null || isReadOnly is null || getterModifier is null || setterModifier is null)
				{
					continue;
				}

				var fieldName = $"_{propertyName.Substring(0, 1).ToLower() + propertyName.Substring(1)}";

				source.Append($@"
        private {propertyType} {fieldName};");

				source.Append($@"
        public {propertyType} {propertyName}
        {{
            {ChooseModifier(getterModifier.Value)}get => this.{fieldName};");

				if (!isReadOnly.Value)
				{
					source.Append($@"
            {ChooseModifier(setterModifier.Value)}set => this.RaiseAndSetIfChanged(ref {fieldName}, value);");
				}

				source.Append($@"
        }}");
			}

			source.Append($@"
    }}
}}");

			return source.ToString();
		}

		private class SyntaxReceiver : ISyntaxReceiver
		{
			public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

			public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
			{
				if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
				    && classDeclarationSyntax.AttributeLists.Count > 0)
				{
					CandidateClasses.Add(classDeclarationSyntax);
				}
			}
		}
	}
}