using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace WalletWasabi.Fluent.Generators;

[Generator(LanguageNames.CSharp)]
public class StaticViewLocatorGenerator : IIncrementalGenerator
{
	private static SymbolDisplayFormat GeneratorSymbolDisplayFormat = new(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
		genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

	private const string StaticViewLocatorAttributeDisplayString = "WalletWasabi.Fluent.StaticViewLocatorAttribute";

	private const string ViewModelSuffix = "ViewModel";

	private const string ViewSuffix = "View";

	private const string AttributeText =
		"""
		// <auto-generated />
		using System;

		namespace WalletWasabi.Fluent;

		[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		public sealed class StaticViewLocatorAttribute : Attribute
		{
		}

		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static ctx =>
			 ctx.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8)));

		// Find all classes that ends with "ViewModel" suffix.
		var viewModelsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax classDeclaration
					&& classDeclaration.Identifier.ValueText.EndsWith(ViewModelSuffix, StringComparison.Ordinal),
				transform: static (ctx, cancellationToken) =>
				{
					var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken);

					if (symbol is INamedTypeSymbol namedTypeSymbol && !namedTypeSymbol.IsAbstract && namedTypeSymbol.Name.EndsWith(ViewModelSuffix, StringComparison.Ordinal))
					{
						return namedTypeSymbol;
					}

					return null!;
				})
			.Where(static symbol => symbol is not null)
			.Select(static (symbol, _) => symbol!)
			.Collect();


		// Find all classes with the [StaticViewLocator] attribute.
		var locatorProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
			StaticViewLocatorAttributeDisplayString,
			static (node, _) => node is ClassDeclarationSyntax,
			static (attributeContext, _) => (INamedTypeSymbol)attributeContext.TargetSymbol);

		// Combine previous two providers with the compilation.
		var inputs = locatorProvider
			.Combine(context.CompilationProvider)
			.Combine(viewModelsProvider);

		context.RegisterSourceOutput(inputs, static (sourceProductionContext, tuple) => 
		{
			var ((locatorSymbol, compilation), viewModelSymbols) = tuple;

			var classSource = ProcessClass(compilation, locatorSymbol, viewModelSymbols);
			if (classSource is not null)
			{
				sourceProductionContext.AddSource($"{locatorSymbol.Name}_StaticViewLocator.cs", SourceText.From(classSource, Encoding.UTF8));
			}
		});
	}

	private static string? ProcessClass(Compilation compilation, INamedTypeSymbol locatorSymbol, ImmutableArray<INamedTypeSymbol> viewModelSymbols)
	{
		if (!locatorSymbol.ContainingSymbol.Equals(locatorSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
		{
			return null;
		}

		var @namespace = locatorSymbol.ContainingNamespace.ToDisplayString();
		var className = locatorSymbol.ToDisplayString(GeneratorSymbolDisplayFormat);

		var relevantViewModelSymbols = new List<INamedTypeSymbol>();
		var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

		foreach (var symbol in viewModelSymbols)
		{
			if (seen.Add(symbol))
			{
				relevantViewModelSymbols.Add(symbol);
			}
		}

		relevantViewModelSymbols.Sort(static (left, right) =>
			string.Compare(left.ToDisplayString(), right.ToDisplayString(), StringComparison.Ordinal));

		var source = new StringBuilder(
			$$"""
			// <auto-generated />
			#nullable enable
			using System;
			using System.Collections.Generic;
			using Avalonia.Controls;

			namespace {{@namespace}};

			public partial class {{className}}
			{
				private static Dictionary<Type, Func<Control>> s_views = new()
				{

			""");

		var userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.UserControl");

		foreach (var viewModelSymbol in relevantViewModelSymbols)
		{
			var namespaceNameViewModel = viewModelSymbol.ContainingNamespace.ToDisplayString();
			var classNameViewModel = $"{namespaceNameViewModel}.{viewModelSymbol.ToDisplayString(GeneratorSymbolDisplayFormat)}";
			var classNameView = classNameViewModel.Replace(ViewModelSuffix, ViewSuffix);

			var classNameViewSymbol = compilation.GetTypeByMetadataName(classNameView);
			if (classNameViewSymbol is null || classNameViewSymbol.BaseType?.Equals(userControlViewSymbol, SymbolEqualityComparer.Default) != true)
			{
				source.AppendLine($"\t\t[typeof({classNameViewModel})] = () => new TextBlock() {{ Text = \"Not Found: {classNameView}\" }},");
			}
			else
			{
				source.AppendLine($"\t\t[typeof({classNameViewModel})] = () => new {classNameView}(),");
			}
		}

		source.Append(
			"""
				};
			}
			""");

		return source.ToString();
	}
}
