using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace WalletWasabi.Fluent.Generators;

[Generator]
public class StaticViewLocatorGenerator : IIncrementalGenerator
{
	private const string StaticViewLocatorAttributeDisplayString = "WalletWasabi.Fluent.StaticViewLocatorAttribute";

	private const string ViewModelSuffix = "ViewModel";

	private const string ViewSuffix = "View";

	private const string AttributeText =
		"""
		// <auto-generated />
		using System;

		namespace WalletWasabi.Fluent;

		[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		public sealed class StaticViewLocatorAttribute : Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// System.Diagnostics.Debugger.Launch();
		context.RegisterPostInitializationOutput(i => i.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8)));

		IncrementalValuesProvider<INamedTypeSymbol?> locatorProvider =
			context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: static (node, _) => node is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0,
					transform: static (ctx, cancellationToken) =>
					{
						ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)ctx.Node;
						INamedTypeSymbol? namedTypeSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, cancellationToken);

						if (namedTypeSymbol is null)
						{
							return null;
						}

						var attributes = namedTypeSymbol.GetAttributes();
						if (attributes.Any(ad => ad?.AttributeClass?.ToDisplayString() == StaticViewLocatorAttributeDisplayString))
						{
							return namedTypeSymbol;
						}

						return null;
					})
				.Where(static symbol => symbol is not null);

		IncrementalValuesProvider<INamedTypeSymbol?> viewModelProvider =
			context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: static (node, _) => node is ClassDeclarationSyntax cds && cds.Identifier.ValueText.EndsWith(ViewModelSuffix),
					transform: static (ctx, cancellationToken) =>
					{
						var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken);

						if (symbol is INamedTypeSymbol namedTypeSymbol && !namedTypeSymbol.IsAbstract && namedTypeSymbol.Name.EndsWith(ViewModelSuffix))
						{
							return namedTypeSymbol;
						}

						return null;
					})
				.Where(static symbol => symbol is not null);

		IncrementalValueProvider<(Compilation Compilation, ImmutableArray<INamedTypeSymbol?> Locators, ImmutableArray<INamedTypeSymbol?> ViewModels)> combined =
			context.CompilationProvider
				.Combine(locatorProvider.Collect())
				.Combine(viewModelProvider.Collect())
				.Select(static (pair, _) => (pair.Left.Left, pair.Left.Right, pair.Right));

		context.RegisterSourceOutput(combined, (spc, tuple)
			=> Execute(spc, tuple.Compilation, tuple.Locators, tuple.ViewModels));
	}

	private static void Execute(
		SourceProductionContext spc,
		Compilation compilation,
		ImmutableArray<INamedTypeSymbol?> locatorSymbols,
		ImmutableArray<INamedTypeSymbol?> viewModelSymbols)
	{
		if (locatorSymbols.IsDefaultOrEmpty || viewModelSymbols.IsDefaultOrEmpty)
		{
			return;
		}

		var attributeSymbol = compilation.GetTypeByMetadataName(StaticViewLocatorAttributeDisplayString);
		if (attributeSymbol is null)
		{
			return;
		}

		var namedTypeSymbolViewModels = viewModelSymbols
			.Where(s => s is not null)
			.Cast<INamedTypeSymbol>()
			.ToList();

		namedTypeSymbolViewModels.Sort((x, y) => x.ToDisplayString().CompareTo(y.ToDisplayString()));

		INamedTypeSymbol? userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.UserControl");

		var format = new SymbolDisplayFormat(
			typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
			genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

		foreach (INamedTypeSymbol? namedTypeSymbolLocator in locatorSymbols)
		{
			if (namedTypeSymbolLocator is null)
			{
				continue;
			}

			if (!namedTypeSymbolLocator.ContainingSymbol.Equals(namedTypeSymbolLocator.ContainingNamespace, SymbolEqualityComparer.Default))
			{
				continue;
			}

			string namespaceNameLocator = namedTypeSymbolLocator.ContainingNamespace.ToDisplayString();
			string classNameLocator = namedTypeSymbolLocator.ToDisplayString(format);

			var source = new StringBuilder(
				$$"""
				// <auto-generated />
				#nullable enable
				using System;
				using System.Collections.Generic;
				using Avalonia.Controls;

				namespace {{namespaceNameLocator}};

				public partial class {{classNameLocator}}
				{
					private static Dictionary<Type, Func<Control>> s_views = new()
					{
				
				""");

			foreach (var namedTypeSymbolViewModel in namedTypeSymbolViewModels)
			{
				string namespaceNameViewModel = namedTypeSymbolViewModel.ContainingNamespace.ToDisplayString();
				string classNameViewModel = $"{namespaceNameViewModel}.{namedTypeSymbolViewModel.ToDisplayString(format)}";
				string classNameView = classNameViewModel.Replace(ViewModelSuffix, ViewSuffix);

				var classNameViewSymbol = compilation.GetTypeByMetadataName(classNameView);
				if (classNameViewSymbol is null || classNameViewSymbol.BaseType?.Equals(userControlViewSymbol, SymbolEqualityComparer.Default) != true)
				{
					source.AppendLine(
						$$"""
								[typeof({{classNameViewModel}})] = () => new TextBlock() { Text = {{("\"Not Found: " + classNameView + "\"")}} },
						""");
				}
				else
				{
					source.AppendLine(
						$$"""
								[typeof({{classNameViewModel}})] = () => new {{classNameView}}(),
						""");
				}
			}

			source.Append(
				"""
					};
				}
				""");

			spc.AddSource($"{namedTypeSymbolLocator.Name}_StaticViewLocator.cs", SourceText.From(source.ToString(), Encoding.UTF8));
		}
	}
}
