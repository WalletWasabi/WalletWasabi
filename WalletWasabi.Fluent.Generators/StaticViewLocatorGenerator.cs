using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace WalletWasabi.Fluent.Generators;

[Generator]
public class StaticViewLocatorGenerator : IIncrementalGenerator
{
	private static SymbolDisplayFormat GeneratorSymbolDisplayFormat = new(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
		genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints | SymbolDisplayGenericsOptions.IncludeVariance);

	private static readonly string[] StaticViewLocatorAttributeType = ["WalletWasabi", "Fluent", "StaticViewLocatorAttribute"];

	private const string StaticViewLocatorAttributeDisplayString = "WalletWasabi.Fluent.StaticViewLocatorAttribute";

	private const string ViewModelSuffix = "ViewModel";

	private const string ViewSuffix = "View";

	private const string AttributeText =
		"""
		// <auto-generated />
		using System;

		namespace WalletWasabi.Fluent;

		[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		public sealed class StaticViewLocatorAttribute : Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// System.Diagnostics.Debugger.Launch();
		context.RegisterPostInitializationOutput(i => i.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8)));

		// Find all classes with the [StaticViewLocator] attribute.
		IncrementalValuesProvider<INamedTypeSymbol> locatorProvider =
			context.SyntaxProvider.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0,
				transform: static (ctx, cancellationToken) =>
				{
					var classDeclarationSyntax = (ClassDeclarationSyntax)ctx.Node;
					var namedTypeSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, cancellationToken);

					if (namedTypeSymbol is null)
					{
						return null!;
					}

					if (namedTypeSymbol.GetAttributes().Any(ad => IsStaticViewLocatorAttribute(ad)))
					{
						return namedTypeSymbol;
					}

					return null!;
				})
			.Where(static symbol => symbol is not null);

		// Find all classes that ends with "ViewModel" suffix.
		IncrementalValuesProvider<INamedTypeSymbol> viewModelProvider =
			context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: static (node, _) => node is ClassDeclarationSyntax c
						&& c.Identifier.ValueText.EndsWith(ViewModelSuffix, StringComparison.Ordinal),
					transform: static (ctx, cancellationToken) =>
					{
						var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken);

						if (symbol is INamedTypeSymbol namedTypeSymbol && !namedTypeSymbol.IsAbstract && namedTypeSymbol.Name.EndsWith(ViewModelSuffix, StringComparison.Ordinal))
						{
							return namedTypeSymbol;
						}

						return null!;
					})
				.Where(static symbol => symbol is not null);

		// Combine previous two providers with the compilation.
		IncrementalValueProvider<(Compilation Compilation, ImmutableArray<INamedTypeSymbol> Locators, ImmutableArray<INamedTypeSymbol> ViewModels)> combined =
			context.CompilationProvider
				.Combine(locatorProvider.Collect())
				.Combine(viewModelProvider.Collect())
				.Select(static (pair, _) => (pair.Left.Left, pair.Left.Right, pair.Right));

		context.RegisterSourceOutput(combined, (spc, tuple)
			=> Execute(spc, tuple.Compilation, tuple.Locators, tuple.ViewModels));
	}

	private static void Execute(
		SourceProductionContext spc,
		Compilation compilation,
		ImmutableArray<INamedTypeSymbol> viewLocatorSymbols,
		ImmutableArray<INamedTypeSymbol> notSortedViewModelSymbols)
	{
		if (viewLocatorSymbols.IsDefaultOrEmpty || notSortedViewModelSymbols.IsDefaultOrEmpty)
		{
			return;
		}

		var attributeSymbol = compilation.GetTypeByMetadataName(StaticViewLocatorAttributeDisplayString);
		if (attributeSymbol is null)
		{
			return;
		}

		var viewModelSymbols = notSortedViewModelSymbols.Sort((x, y) => x.ToDisplayString().CompareTo(y.ToDisplayString()));

		INamedTypeSymbol? userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.UserControl");

		foreach (INamedTypeSymbol viewLocatorSymbol in viewLocatorSymbols)
		{
			if (!viewLocatorSymbol.ContainingSymbol.Equals(viewLocatorSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
			{
				continue;
			}

			string @namespace = viewLocatorSymbol.ContainingNamespace.ToDisplayString();
			string className = viewLocatorSymbol.ToDisplayString(GeneratorSymbolDisplayFormat);

			var source = new StringBuilder(
				$$"""
				// <auto-generated />
				#nullable enable
				using System;
				using System.Collections.Generic;
				using Avalonia.Controls;

				namespace {{@namespace}};

				public partial class {{className}}
				{
					private static Dictionary<Type, Func<Control>> s_views = new()
					{
				
				""");

			foreach (var viewModelSymbol in viewModelSymbols)
			{
				string namespaceNameViewModel = viewModelSymbol.ContainingNamespace.ToDisplayString();
				string classNameViewModel = $"{namespaceNameViewModel}.{viewModelSymbol.ToDisplayString(GeneratorSymbolDisplayFormat)}";
				string classNameView = classNameViewModel.Replace(ViewModelSuffix, ViewSuffix);

				var classNameViewSymbol = compilation.GetTypeByMetadataName(classNameView);
				if (classNameViewSymbol is null || classNameViewSymbol.BaseType?.Equals(userControlViewSymbol, SymbolEqualityComparer.Default) != true)
				{
					source.AppendLine(
						$$"""
								[typeof({{classNameViewModel}})] = () => new TextBlock() { Text = {{"\"Not Found: " + classNameView + "\""}} },
						""");
				}
				else
				{
					source.AppendLine(
						$$"""
								[typeof({{classNameViewModel}})] = () => new {{classNameView}}(),
						""");
				}
			}

			source.Append(
				"""
					};
				}
				""");

			spc.AddSource($"{viewLocatorSymbol.Name}_StaticViewLocator.cs", SourceText.From(source.ToString(), Encoding.UTF8));
		}
	}

	// Checks if the provided attribute data corresponds to [StaticViewLocatorAttribute].
	private static bool IsStaticViewLocatorAttribute(AttributeData? attributeData)
	{
		var type = attributeData?.AttributeClass;

		if (type is null)
		{
			return false;
		}

		var ns = type.ContainingNamespace;
		if (ns?.Name != StaticViewLocatorAttributeType[2])
		{
			return false;
		}

		ns = ns.ContainingNamespace;
		if (ns?.Name != StaticViewLocatorAttributeType[1])
		{
			return false;
		}

		ns = ns.ContainingNamespace;
		if (ns is null || !ns.IsGlobalNamespace)
		{
			return false;
		}

		return type.Name == StaticViewLocatorAttributeType[0];
	}
}
